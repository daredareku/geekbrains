Сначала скачиваем по Инструкции c habr “Веса Vicuna опубликованы. Теперь можно поиграться с самой продвинутой ChatGPT-like моделью на домашнем компьютере” эту Викунью с Размером контекста, 2048 токенов против 512. Генерирует код Викунья 13 b причем на разных языках где-то слово в секунду на обычном процессоре. Нужен многоядерник с инструкциями AVX2 или AVX512 чтобы работало прилично быстро, как AI на сайте poe.com.
Запуск простой:
1) git clone https://github.com/ggerganov/llama.cpp.git
2) качаем модель и кладём туда же
3) make
4) ./main -i --interactive-first -r "### Human:" --temp 0 -c 2048 -n -1 --ignore-eos --repeat_penalty 1.2 --instruct -m ggml-vicuna-13b-4bit.bin
Если у вас CPU с большим количеством тредов, можно посмотреть на параметр -t X. 

Создаем батник:
main -i -t 8 --interactive-first -r "### Human:" --temp 0 -c 2048 -n -1 --ignore-eos --repeat_penalty 1.2 --instruct -m ggml-vicuna-13b-4bit.bin >> output.txt 
.
Модель  LLAMA jn Github https://github.com/ggerganov/llama.cpp/releases/tag/master-0b2da20 
Нас интересует там файл main.exe
Сам файл ggml-vicuna-13b-4bit.bin Скачиваем
Преобразуем в DLL  С++ код и запускаем с вместе со своим проектом для получения инструмента на своем компьютере
я могу объяснить, как использовать DLL в проекте на C++. Вот общие шаги:
1.	Сначала вам нужно объявить функцию(и), которые вы хотите использовать из DLL в вашем коде на C++. Для этого создайте заголовочный файл, который объявляет прототипы функций с ключевым словом extern, например:
c
Copy
extern "C" {
    void myFunction();
    int myOtherFunction(int arg1, float arg2);
}
```

Обратите внимание, что блок `extern "C"` используется для указания того, что функции должны быть экспортированы с использованием имен и вызовов в стиле C, которые совместимы с DLL.

2.	Затем вам нужно загрузить DLL в вашу программу с помощью функции LoadLibrary, например:
c
Copy
HINSTANCE hDll = LoadLibrary("mydll.dll");
if (hDll == NULL) {
    // Обработайте ошибку
}
```

Эта функция возвращает дескриптор загруженной DLL, который вы можете использовать для доступа к ее функциям.

3.	Как только DLL загружена, вы можете получить указатель на функцию, вызвав функцию GetProcAddress, например:
c
typedef void (*MYFUNCTION)();
MYFUNCTION myFunction = (MYFUNCTION)GetProcAddress(hDll, "myFunction");
if (myFunction == NULL) {
    // Обработайте ошибку
}
```

Этот код определяет тип указателя на функцию `MYFUNCTION`, соответствующий сигнатуре `myFunction`, а затем получает указатель на функцию по ее имени.

4.	Наконец, вы можете вызвать функцию DLL, используя указатель на функцию, например:
c
myFunction();
```

Этот код вызывает функцию `myFunction`, экспортированную DLL.

5.	Когда вы закончите использовать DLL, вы должны выгрузить ее, используя функцию FreeLibrary, например:
c
FreeLibrary(hDll);
```

Это освобождает ресурсы, используемые DLL, и выгружает ее из адресного пространства вашей программы.
Это основной процесс использования DLL в программе на C++. Конечно, детали могут различаться в зависимости от конкретной DLL и функций, которые вы используете.
continue Вывод:
Кроме того, при использовании DLL в C++ проекте вы можете столкнуться с другими вопросами, такими как управление памятью, передача параметров, обработка ошибок и т.д. Например, если функция в DLL возвращает указатель на память, вы должны быть осторожны при ее освобождении, чтобы избежать утечек памяти.
Также имейте в виду, что некоторые функции в DLL могут иметь зависимости от других библиотек или ресурсов, которые также должны быть доступны в вашей программе. Поэтому важно проверить документацию и требования к DLL перед ее использованием.
Наконец, убедитесь, что вы используете правильную архитектуру DLL для вашей программы (например, x86 или x64), и что вы компилируете вашу программу и DLL совместимыми компиляторами и настройками.
В целом, использование DLL в C++ может быть полезным и эффективным способом повторного использования кода и снижения размера исходного кода вашей программы. Однако это требует некоторой дополнительной работы по управлению памятью, обработке ошибок и другим аспектам, связанным с использованием внешних библиотек.

Вывод: В целом, Vicuna AI - это платформа, которая предоставляет инструменты для создания и развертывания искусственного интеллекта и машинного обучения. Она может быть полезна для разработчиков, исследователей и бизнес-аналитиков, которые хотят создавать и применять модели машинного обучения для решения различных задач.
Vicuna AI предоставляет интуитивно понятный пользовательский интерфейс, который позволяет пользователям создавать модели машинного обучения, обучать их на основе данных, выполнять тестирование и оптимизацию моделей, а также развертывать их в рабочей среде.
Она также поддерживает различные языки программирования, такие как Python, R и Java, и позволяет пользователям использовать различные инструменты и библиотеки машинного обучения, такие как TensorFlow, Keras, PyTorch и Scikit-learn.
Кроме того, Vicuna AI предоставляет возможности для совместной работы и управления проектами, что делает ее полезной для командной работы и совместного использования ресурсов.
В целом, Vicuna AI может быть полезной платформой для создания и развертывания моделей машинного обучения, и она предоставляет широкий спектр инструментов и функций для удобства и эффективности работы.

